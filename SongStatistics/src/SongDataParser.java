import java.nio.file.Path;
import static org.junit.Assert.fail;
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.util.ArrayList;


//Martin Murphy
//CS212
//1/29/2016
//HW1


public class SongDataParser {
	
	private int numSongs;
	private int numSim;
	private double simMean;
	ArrayList<String> songs;

	// Constructor
	public SongDataParser(Path path,Boolean isRecursive) {
		this.songs = new ArrayList<>();
		this.numSongs = 0;
		this.numSim = 0;
		this.simMean=0;
		//this.simMean2=0;
		sdpHelper(path, ".json", songs,isRecursive);
		//sdpParser();
	}

// this comment is not sufficient a proper comment would be like this:
/**
 * what the function does
 * @param - paramter name, describe the paramter
 * @return - describe what the funtion returns
 */

	//Build Paths Helper 
	private void sdpHelper(Path path, String extension, ArrayList<String>songs,Boolean isRecursive) {
	//for(isRecursive=True){
		if(Files.isDirectory(path)) {
			try(DirectoryStream<Path> dir = 
				Files.newDirectoryStream(path)) {
				for(Path entry: dir) {
					sdpHelper(entry, extension, songs,isRecursive);
				}
			} catch (IOException e) {
				
				e.printStackTrace();
				//Object badPath = null;
				//println("Exception generated by SongDataParser constructor with bad path: " + badPath.toString());			
				//fail("Exception generated by SongDataParser constructor with bad path: " + badPath.toString());
			}
		} else if(path.toString().endsWith(extension.toLowerCase().trim())) {
			songs.add(path.toString());
			numSongs=songs.size();
		}	
	}

	//Read Helper
	private void sdpParser() {
		
		for (String song : this.songs) {
			//Parse JSON
			JSONParser parser = new JSONParser();
			//Open
			try (BufferedReader reader = Files.newBufferedReader(Paths.get(song), Charset.forName("UTF-8"))) {
				//Read
				String line = reader.readLine();			
				//Next line
				while(line != null) {

					//Create a JSONObject
					JSONObject contents = (JSONObject) parser.parse(line);
					//Get similar songs
					ArrayList<String> songs = (ArrayList<String>) contents.get("similars");
					//Temp variable adding similar count
					numSim += songs.size();
					line = reader.readLine();
					
//					simMean = numSim/numSongs;
//					System.out.println(numSim);					
				}

			} catch (IOException e) {
				e.printStackTrace();
/*print some helpful info for debug like this*/
/*System.err.println("Failed to open file on path: " + path.toString());*/		
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		simMean = (double) (numSim/numSongs);
		
		//System.out.println(simMean);		
		//return simMean;
	}

	//Returns Similar song data
	public double getMeanNumberSimilarSongs() {	
		//((SongDataParser) recursiveSDP).sdpParser();
		sdpParser();
		return this.simMean;
		//return recursiveSDP.sdpParser();
	}

	//Return total songs given path
	public int getSongCount() {
		//sdpParser(path, ".json", songs);
		return this.numSongs;
	}

	public static void main(String[] args) {
		//Tests
		Path recursivePath = Paths.get("lastfm_subset/");
		SongDataParser recursiveSDP = new SongDataParser(recursivePath,true);
		System.out.printf("Recursive \n");
		System.out.printf("Song Count: %d\n",recursiveSDP.getSongCount());
		System.out.printf("Mean %f\n", recursiveSDP.getMeanNumberSimilarSongs());	
						
		Path nonRecursivePath = Paths.get("lastfm_subset/A/W/K");
		SongDataParser nonRecursiveSDP = new SongDataParser(nonRecursivePath,false);
		System.out.printf("nonRecursive \n");
		System.out.printf("Song Count: %d\n",nonRecursiveSDP.getSongCount());
		System.out.printf("Mean: %f\n",nonRecursiveSDP.getMeanNumberSimilarSongs());

		
}
}
